### [1.1. Intro to L1](https://www.youtube.com/watch?v=hYNG0Guezpk)
- symetric/asymetric encryption
- digital signatures
- hash functions
- merkle tree / merkle patricia tree / verkle tree
- blockchain timeline:
    - pre-1970s symetric cryptography
    - 1970s asymetric cryptography: Diffie Helman Key Exchange ([ot](https://github.com/archit-p/simplest-oblivious-transfer))
    - 1980s David Chaum - Blind Signatures / Digicash
    - 1990s Adam Back - HashCash / [Wei Dai - B-Money](http://www.weidai.com/bmoney.txt) / [Bit Gold - Nick Szabo](https://nakamotoinstitute.org/bit-gold/)
    - 2000s Peer to peer networks: Freenet / Gnutella / Bit Torrent
    - 2008 [Bitcoin](https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch08.asciidoc)
- blockchain components:
    - a p2p network (based on "gossip" protocol)
    - messages (txs) representing state transitions
    - consensus rules (determines valid state transitions)
    - a state machine that processes txs according to consensus
    - a chain of cryptographically secured blocks
    - a consensus algorithm to enforce the consensus rules
    - a game-theory incentive scheme
    - one or more open source software impementations of the above (clients)
- blockchain architecture:
    - network: all participants are equal (p2p), no "special" nodes, no server, no centralised service, no hierarchy
    - nodes:
        - accept and transmit txs
        - keep a mempool
        - provide network discovery (via DNS seed nodes / locally stored list) and routing functions
        - drop connections to misbehaving nodes
        - accept blocks and update local ledger
        - connections are based on proximity in a hash table, not on geographical proximity
    - block data structure: header, timestamp, parent hash, nonce, txs
    - storage data structures: organised in Merkle trees / Merkle Patricia trees
    - alternative data structures: DAG (Sui/IOTA)
    - modular blockchains: [deep dive](https://volt.capital/blog/modular-blockchains) / [blockspace](https://www.paradigm.xyz/2021/03/ethereum-blockspace-who-gets-what-and-why)
        - execution: smart contracts business logic impl. Can be moved away from the evm (Starknet)
        - settlement/consensus: agreement on state transitions. Is securing the updates to the execution layer
        - data availability: the ability to verify that the information for a block is actually published on the blockchain network
- [ethereum consensus](https://ethereum.org/en/developers/docs/consensus-mechanisms/)
    - Technically, proof-of-work and proof-of-stake are not consensus protocols by themselves, but they are often referred to as such for simplicity. They are actually Sybil resistance mechanisms and block author selectors; they are a way to decide who is the author of the latest block. It is this Sybil resistance mechanism combined with a chain selection rule that makes up a true consensus mechanism.
    - block addition has two parts: 
        - block producer selection
        - block acceptance
    - pre-merge:
        - Beacon Chain wasn't processing Mainnet transactions. Was only reaching consensus on its own state (active validators and their account balances - [specs](https://github.com/ethereum/consensus-specs#phase-0)).
    - post-merge:
        - Eth 1.0 continue to handle execution (process blocks, maintain mempool, manage and sync state). PoW has been taken out
        - Beacon Chain continues to handle PoS consensus (track chain's head, gossip, attest blocks, receive validator rewards)
    - [execution clients](https://ethereum.org/en/developers/docs/nodes-and-clients/#execution-clients)
    - [consensus clients](https://ethereum.org/en/developers/docs/nodes-and-clients/#consensus-clients)
    - [client diversity](https://ethereum.org/en/developers/docs/nodes-and-clients/client-diversity/)
    - block finality: 
        - tendermint chains can halt if they don't get enough votes
        - nakamoto continue to add blocks and may not achieve finality
        - Ethereum achives finality by checkpointing (epochs every ~6min)

### [1.2. Why Scalability](https://www.youtube.com/watch?v=IIve3zX2xnw)
- Introduction:
    - regular users can run an eth node ([vitalik](https://vitalik.ca/general/2021/05/23/scaling.html))
    - Ethereum goal is to keep hardware requirements low ([scaling](https://ethereum.org/en/developers/docs/scaling/))
    - blockchain performance is [hard to measure](https://a16zcrypto.com/posts/article/why-blockchain-performance-is-hard-to-measure/) and TPS can have little real value

- Layer 1 solutions
    - eth validators form comittees and votes are aggregated by them
    - solana moved away from gossip protocol => only the leader (block producer) needs to receive txs so nodes send them to the leader not to the other nodes
    - eth txs are ordered and executed sequentially => simple design but leads to MEV / poor horizontal scaling
    - solana / aptos / sui allow parallel processing of  (non dependent) txs
    - sharding:
        - eth will have 64 shards
        - [introduction](https://medium.com/@icebearhww/ethereum-sharding-and-finality-65248951f649)
        - vitalik's [overview](https://vitalik.ca/general/2021/04/07/sharding.html) & [limits](https://vitalik.ca/general/2021/05/23/scaling.html)
    - rollups:
        - txs are commited to main chain in bundles (they are rolled-up)
        - tx execution outside L1
        - data / proof of txs is on L1
        - rollup smart contract on L1 that can enforce correct tx execution on L2 by using the tx data from L1
        - needs either optimistic or zk ([fraud proof vs. validity proof](https://www.alchemy.com/overviews/validity-proof-vs-fraud-proof#:~:text=What%20is%20a%20validity%20proof,information%20shared%20between%20the%20two.))
        - validity / zk => operator sumbmits a new state transition AND a cryptographic proof (a zk-SNARK) that the new state is valid transition from the old state. The state transitions is validated by a smart contract on L1. Usually the zero knowledge is ignored and input/data involved is public.
        - optimistic => assumes that the nodes are behaving honestly. State transition can be rolled back by providing a "fraud proof". After a certain period the state transition is considered final on L1.
    - state channels: 2 txs on L1 | eth locked in a multisig contract | either party can exit/close the channel ([lightning network](https://lightning.network))
    - plasma chains ([eth docs](https://ethereum.org/en/developers/docs/scaling/plasma) / [vitalik article](https://vitalik.eth.limo/general/2023/11/14/neoplasma.html)): utilize fraud proofs like optimistic rullups but have the mass exit problem.
    - Polygon [PoS](https://wiki.polygon.technology/docs/pos/) has a three-layer [architecture](https://wiki.polygon.technology/docs/pos/polygon-architecture/):
        - Ethereum layer â€” a set of contracts on the Ethereum mainnet.
        - [Heimdall](https://forum.polygon.technology/t/matic-system-overview-heimdall/8323) layer
        - [Bor](https://wiki.polygon.technology/docs/pos/design/bor/) layer
    - [Skale](https://skale.space)
    - [Loom](https://loomx.io)
- Ethereum Scalability directions:
    - The L2 scaling transition - [everyone moving to rollups](https://ethereum-magicians.org/t/a-rollup-centric-ethereum-roadmap/4698)
    - The wallet security transition - everyone moving to [smart contract wallets](https://vitalik.ca/general/2021/01/11/recovery.html)
    - The privacy transition - making sure privacy-preserving funds transfers are available


### [1.3. Intro to L2s / Maths and Cryptography](https://www.youtube.com/watch?v=DIXFlD-2PGU)
### [1.4. Maths and Cryptography](https://www.youtube.com/watch?v=vi5I2KcMPxo)
